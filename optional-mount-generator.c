#include <config.h>

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>

#include <blkid/blkid.h>
#include <uuid/uuid.h>
#if defined(HAVE_INIPARSER_INIPARSER_H)
#include <iniparser/iniparser.h>
#elif defined(HAVE_INIPARSER_H)
#include <iniparser.h>
#endif

#define NDEVS (16)

uuid_t *device_uuids;
int alloc_device_uuids;
int n_device_uuids;

void parse_ini_file(const char *ininame, const char *output_dir, int output_dir_len) {
	dictionary *dict = iniparser_load(ininame);
	int sections, i;

	if (!dict)
		return;

	sections = iniparser_getnsec(dict);

	for (i = 0; i < sections; i++) {
		const char *sect = iniparser_getsecname(dict, i);
		int sectlen = strlen(sect) + 1;
		int nkeys = iniparser_getsecnkeys(dict, sect);

		const char **keys0 = malloc(nkeys * sizeof(char *));
		const char **keys;
		const char *uuid = NULL, *opts = NULL, *desc = NULL;
		int j;

		keys = iniparser_getseckeys(dict, sect, keys0);

		for (j = 0; j < nkeys; j++) {
			const char *onlykey = keys0[j] + sectlen;
			const char *val = iniparser_getstring(dict, keys0[j], "");
			if (strcasecmp(onlykey, "UUID") == 0)
				uuid = val;
			else if (strcasecmp(onlykey, "Options") == 0)
				opts = val;
			else if (strcasecmp(onlykey, "Description") == 0)
				desc = val;
		}

		if (uuid) {
			uuid_t uuid_from_ini;
			char uuid_lc[64];
			bool found = false;
			char *unit_name = alloca(strlen(sect) + 48);
			char *output_name = alloca(output_dir_len + strlen(sect) + 48);

			uuid_parse(uuid, uuid_from_ini);
			for (j = 0; j < n_device_uuids; j++) {
				if (uuid_compare(device_uuids[j], uuid_from_ini) == 0) {
					found = true;
					break;
				}
			}

			if (found)
				uuid_unparse_lower(uuid_from_ini, uuid_lc);

			if (found && output_name) {
				FILE *output;
				char *unit_name1;
				int j;

				unit_name[0] = 0;
				unit_name1 = unit_name;
				for (j = 0; sect[j]; j++)
					if (j || sect[j] != '/')
						*unit_name1++ = (sect[j] == '/' ? '-' : sect[j]);
				*unit_name1 = 0;
				strcat(unit_name, ".mount");
				sprintf(output_name, "%s/%s", output_dir, unit_name);

				remove(output_name);

				output = fopen(output_name, "w");
				if (output) {
					char *requires_dirname = alloca(output_dir_len + 32);
					char *symlinkname = alloca(output_dir_len + 128);
					char *fsckservice = alloca(256);
					int fsckservice_len = sprintf(fsckservice, "systemd-fsck@dev-disk-by\\x2duuid-");
					int k;

					for (j = 0, k = fsckservice_len; uuid_lc[j]; j++) {
						if (uuid_lc[j] == '-') {
							fsckservice[k++] = '\\';
							fsckservice[k++] = 'x';
							fsckservice[k++] = '2';
							fsckservice[k++] = 'd';
						} else
							fsckservice[k++] = uuid_lc[j];
					}
					fsckservice[k] = 0;
					strcat(fsckservice, ".service");

					fprintf(output, "# Automatically generated by systemd-optional-mount-generator\n\n"
							"[Unit]\n"
							"SourcePath=%s\n",
							ininame);

					if (desc)
					fprintf(output, "Description=%s\n", desc);

					fprintf(output, "Before=local-fs.target\n"
							"Requires=%s\n"
							"After=%s\n\n"
							"[Mount]\n"
							"Where=%s\n"
							"What=/dev/disk/by-uuid/%s\n",
							fsckservice, fsckservice, sect, uuid_lc);

					if (opts)
					fprintf(output, "Options=%s\n", opts);

					fflush(output);
					fclose(output);

					sprintf(requires_dirname, "%s/local-fs.target.requires", output_dir);
					mkdir(requires_dirname, 0755);

					sprintf(symlinkname, "%s/%s", requires_dirname, unit_name);
					symlink(output_name, symlinkname);
				}
			}
		}

		free(keys);
	}

	iniparser_freedict(dict);
}

int main(int argc, char **argv) {
	blkid_cache cache = NULL;
	char *read = NULL;
	blkid_dev_iterate iter;
	blkid_dev dev;
	const char *output_dir = NULL;
	int output_dir_len = 0;

	if (argc >= 2) {
		output_dir = argv[1];
		output_dir_len = strlen(output_dir);
	}

	if (!output_dir)
		return 0;

	device_uuids = malloc(NDEVS * sizeof(uuid_t));
	alloc_device_uuids = NDEVS;
	n_device_uuids = 0;

	blkid_get_cache(&cache, read);
	blkid_probe_all(cache);
	iter = blkid_dev_iterate_begin(cache);
	blkid_dev_set_search(iter, NULL, NULL);
	while (blkid_dev_next(iter, &dev) == 0) {
		//const char *devname;
		const char *type, *value;
		blkid_tag_iterate itert;

		dev = blkid_verify(cache, dev);
		if (!dev)
			continue;

		//devname = blkid_dev_devname(dev);

		itert = blkid_tag_iterate_begin(dev);
		while (blkid_tag_next(itert, &type, &value) == 0) {
			if (strcasecmp(type, "UUID") == 0) {
				if (!uuid_parse(value, device_uuids[n_device_uuids])) {
					n_device_uuids++;
					if (n_device_uuids >= alloc_device_uuids) {
						int new_alloc_device_uuids = 2 * alloc_device_uuids;
						uuid_t *new_device_uuids = realloc(device_uuids, new_alloc_device_uuids * sizeof(uuid_t));
						if (!new_device_uuids)
							break;

						device_uuids = new_device_uuids;
						alloc_device_uuids = new_alloc_device_uuids;
					}
				}
			}
			//printf("%s: %s: %s\n", devname, type, value);
		}
		blkid_tag_iterate_end(itert);
	}
	blkid_dev_iterate_end(iter);
	blkid_put_cache(cache);
#if 0
	printf("collected %d UUIDs\n", n_device_uuids);
	for (i = 0; i < n_device_uuids; i++) {
		char x[64];
		uuid_unparse(device_uuids[i], x);
		printf("%s\n", x);
	}
#endif

	DIR *dirp = opendir("/etc/systemd-optional-mount");
	struct dirent *de = NULL;

	if (dirp)
		de = readdir(dirp);
	for (; dirp && de; de = readdir(dirp)) {
		char *name = de->d_name;
		int len = strlen(name);

		if (len > 4) {
			char *sfx = name + len - 4;
			if (strcmp(sfx, ".ini") == 0) {
				char *ininame = NULL;
				int inilen;

				inilen = snprintf(NULL, 0, "/etc/systemd-optional-mount/%s", name);
				ininame = malloc(inilen + 1);
				snprintf(ininame, inilen + 1, "/etc/systemd-optional-mount/%s", name);

				parse_ini_file(ininame, output_dir, output_dir_len);

				free(ininame);
			}
		}
	}

	closedir(dirp);

	return 0;
}
